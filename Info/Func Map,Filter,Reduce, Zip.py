from functools import reduce


print("~~~~~~~Часть 1~~~~~~~")
# В Python функция map принимает два аргумента: функцию и аргумент составного
# типа данных,
# например, список. map применяет к каждому элементу списка переданную функцию.

# Открыли файл
with open("for map.txt") as f:

    # В переменную "n" записывается строка с типом int из файла

    n = int(f.readline())

# цикл перебора для "n" с набором параметров для итерируемого объекта
# f.readline().split() запись каждой строки с разделением по пробелу.
# int делает каждую строку целочисленного типа
    for i in range(n):
        a, b = map(int, f.readline().split())
        print(a+b)
# В текстовом документе первой строкой нужно указать кол-во строк цикла.
# Причём первая строка не считается так как мы её уже прошли
# в начале n = int(f.readline())
# По итогу мы изменили список с текста на цифры и можем ими оперировать

print("~~~~~~~Часть 2~~~~~~~")
# передали аркументы списка в функцию f


def f(a, b):
    return a * b


a = map(f, [2, 4, 5, ], [5, 6, 7])
print(list(a))

print("~~~~~~~Часть 3~~~~~~~")
# Пример с lambda функцией
a = map(lambda x: x + 15, (2, 4, 5))
print(list(a))

print("~~~~~~~Часть 4~~~~~~~")
# filter сверяет с заданием по методу true/false, и возвращает true


def f(a):
    if a % 2 == 0:
        return a


a = filter(f, (2, 4, 5))
print(list(a))

print("~~~~~~~Часть 5~~~~~~~")
# Пример с lambda функцией
a = filter(lambda x: (x < 15), (5, 10, 15, 16, 1))
print(list(a))

print("~~~~~~~Часть 6~~~~~~~")
# Функция reduce принимает 2 аргумента: функцию и последовательность.
# reduce() последовательно применяет функцию-аргумент к элементам списка,
# возвращает единичное значение.
print(reduce(lambda a, b: a * b, (1, 2, 4, 5,)))

print("~~~~~~~Часть 7~~~~~~~")
# объединение 2-ух последовательностей по элементам
a = [1, 2, 3, 4, 5, 6, ]
b = 'abcdef'

result = zip(a, b)
print(list(result))
